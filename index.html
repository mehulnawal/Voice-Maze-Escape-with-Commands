<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Maze - Talk to Escape</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0f0f23, #1a1a3e, #0f0f23);
            overflow: hidden;
        }

        .glitch {
            position: relative;
        }

        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch::before {
            animation: glitch-1 0.5s infinite;
            color: #ff0040;
            z-index: -1;
        }

        .glitch::after {
            animation: glitch-2 0.5s infinite;
            color: #00ffff;
            z-index: -2;
        }

        @keyframes glitch-1 {

            0%,
            14%,
            15%,
            49%,
            50%,
            99%,
            100% {
                transform: translate(0);
            }

            15%,
            30% {
                transform: translate(-2px, 1px);
            }

            50%,
            65% {
                transform: translate(2px, -1px);
            }
        }

        @keyframes glitch-2 {

            0%,
            19%,
            20%,
            39%,
            40%,
            79%,
            80%,
            100% {
                transform: translate(0);
            }

            20%,
            35% {
                transform: translate(2px, 1px);
            }

            40%,
            55% {
                transform: translate(-1px, -2px);
            }
        }

        .neon-glow {
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }

        .pulse-border {
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {

            0%,
            100% {
                border-color: #00ffff;
            }

            50% {
                border-color: #ff0040;
            }
        }

        canvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .voice-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff0040;
            animation: pulse 1s infinite;
        }

        .voice-indicator.listening {
            background: #00ff00;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">
    <div class="text-center mb-6">
        <h1 class="text-4xl font-black mb-2 glitch neon-glow" data-text="VOICE MAZE">VOICE MAZE</h1>
        <p class="text-cyan-400 text-lg">üéôÔ∏è Talk to Escape - Say "left", "right", "up", "down", or "stop"</p>
    </div>

    <div class="flex flex-col lg:flex-row gap-6 items-start">
        <!-- Game Canvas -->
        <div class="relative">
            <canvas id="mazeCanvas" width="600" height="400" class="pulse-border"></canvas>
            <div id="gameStatus" class="absolute top-4 left-4 bg-black bg-opacity-70 px-3 py-2 rounded text-cyan-400">
                Find the exit! üö™
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="bg-gray-800 bg-opacity-90 p-6 rounded-lg border border-cyan-400 min-w-[300px]">
            <div class="flex items-center gap-3 mb-4">
                <div id="voiceIndicator" class="voice-indicator"></div>
                <span id="voiceStatus" class="text-cyan-400">Click to start voice control</span>
            </div>

            <button id="startVoice"
                class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-6 rounded mb-4 transition-all duration-300 transform hover:scale-105">
                üé§ START VOICE CONTROL
            </button>

            <div class="mb-4">
                <h3 class="text-yellow-400 font-bold mb-2">Voice Commands:</h3>
                <ul class="text-sm space-y-1 text-gray-300">
                    <li>‚Ä¢ "left" - Move left</li>
                    <li>‚Ä¢ "right" - Move right</li>
                    <li>‚Ä¢ "up" - Move up</li>
                    <li>‚Ä¢ "down" - Move down</li>
                    <li>‚Ä¢ "stop" - Stop moving</li>
                </ul>
            </div>

            <div class="mb-4">
                <h3 class="text-red-400 font-bold mb-2">Last Command:</h3>
                <div id="lastCommand" class="bg-gray-700 p-2 rounded text-center text-yellow-300">
                    Waiting for voice...
                </div>
            </div>

            <div>
                <h3 class="text-purple-400 font-bold mb-2">Misheard Fun:</h3>
                <div id="mishearEffect" class="bg-gray-700 p-2 rounded text-center text-pink-300 text-sm">
                    Say something wrong for surprises! üòÑ
                </div>
            </div>

            <button id="resetGame"
                class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded mt-4 transition-all duration-300">
                üîÑ RESET MAZE
            </button>
        </div>
    </div>

    <script>
        class VoiceMaze {
            constructor() {
                this.canvas = document.getElementById('mazeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isListening = false;
                this.recognition = null;
                this.player = { x: 1, y: 1, size: 20 };
                this.cellSize = 30;
                this.isMoving = false;
                this.moveDirection = null;
                this.moveSpeed = 2;
                this.gameWon = false;

                // Maze layout (0 = wall, 1 = path, 2 = exit)
                this.maze = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];

                this.init();
            }

            init() {
                this.setupVoiceRecognition();
                this.setupEventListeners();
                this.gameLoop();
                this.draw();
            }

            setupVoiceRecognition() {
                // Check for Speech Recognition support
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    document.getElementById('voiceStatus').textContent = 'Voice recognition not supported in this browser';
                    document.getElementById('startVoice').disabled = true;
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();

                // Configure recognition settings
                this.recognition.continuous = false; // Changed to false for better reliability
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';
                this.recognition.maxAlternatives = 1;

                this.recognition.onstart = () => {
                    console.log('Speech recognition started');
                    this.isListening = true;
                    this.updateVoiceStatus('üé§ Listening... Say a command!', true);
                };

                this.recognition.onend = () => {
                    console.log('Speech recognition ended');
                    this.isListening = false;
                    this.updateVoiceStatus('Click to start voice control', false);

                    // Auto-restart if we were listening (for continuous mode)
                    if (this.shouldKeepListening) {
                        setTimeout(() => {
                            if (this.shouldKeepListening) {
                                this.startListening();
                            }
                        }, 100);
                    }
                };

                this.recognition.onresult = (event) => {
                    console.log('Speech recognition result:', event);

                    if (event.results && event.results.length > 0) {
                        const result = event.results[0];
                        if (result.isFinal) {
                            const command = result[0].transcript.toLowerCase().trim();
                            console.log('Recognized command:', command);
                            this.processVoiceCommand(command);
                        }
                    }
                };

                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.isListening = false;
                    this.shouldKeepListening = false;

                    let errorMessage = 'Voice error - ';
                    switch (event.error) {
                        case 'not-allowed':
                            errorMessage += 'Microphone access denied';
                            break;
                        case 'no-speech':
                            errorMessage += 'No speech detected';
                            break;
                        case 'audio-capture':
                            errorMessage += 'No microphone found';
                            break;
                        case 'network':
                            errorMessage += 'Network error';
                            break;
                        default:
                            errorMessage += 'Try again';
                    }

                    this.updateVoiceStatus(errorMessage, false);

                    // Auto-retry for certain errors
                    if (event.error === 'no-speech' && this.shouldKeepListening) {
                        setTimeout(() => {
                            if (this.shouldKeepListening) {
                                this.startListening();
                            }
                        }, 1000);
                    }
                };

                this.shouldKeepListening = false;
            }

            setupEventListeners() {
                document.getElementById('startVoice').addEventListener('click', () => {
                    this.toggleVoiceControl();
                });

                document.getElementById('resetGame').addEventListener('click', () => {
                    this.resetGame();
                });

                // Keyboard fallback
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case 'ArrowLeft': this.processVoiceCommand('left'); break;
                        case 'ArrowRight': this.processVoiceCommand('right'); break;
                        case 'ArrowUp': this.processVoiceCommand('up'); break;
                        case 'ArrowDown': this.processVoiceCommand('down'); break;
                        case ' ': this.processVoiceCommand('stop'); e.preventDefault(); break;
                    }
                });
            }

            toggleVoiceControl() {
                if (!this.recognition) {
                    alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
                    return;
                }

                if (this.isListening || this.shouldKeepListening) {
                    this.stopListening();
                } else {
                    this.startContinuousListening();
                }
            }

            startContinuousListening() {
                this.shouldKeepListening = true;
                this.startListening();
            }

            startListening() {
                if (this.recognition && !this.isListening) {
                    try {
                        console.log('Starting speech recognition...');
                        this.recognition.start();
                    } catch (error) {
                        console.error('Error starting speech recognition:', error);
                        this.updateVoiceStatus('Failed to start - try again', false);
                    }
                }
            }

            stopListening() {
                this.shouldKeepListening = false;
                if (this.recognition && this.isListening) {
                    this.recognition.stop();
                }
                this.updateVoiceStatus('Voice control stopped', false);
            }

            processVoiceCommand(command) {
                document.getElementById('lastCommand').textContent = `"${command}"`;

                // Add glitch effect to command display
                gsap.fromTo('#lastCommand',
                    { scale: 1, rotationX: 0 },
                    { scale: 1.1, rotationX: 360, duration: 0.5, ease: "back.out(1.7)" }
                );

                // Process actual commands
                if (command.includes('left')) {
                    this.setMovement('left');
                } else if (command.includes('right')) {
                    this.setMovement('right');
                } else if (command.includes('up')) {
                    this.setMovement('up');
                } else if (command.includes('down')) {
                    this.setMovement('down');
                } else if (command.includes('stop')) {
                    this.setMovement(null);
                } else {
                    // Misheard command - create fun effects
                    this.handleMisheardCommand(command);
                }
            }

            handleMisheardCommand(command) {
                const funnyResponses = [
                    "Did you say 'pizza'? üçï",
                    "I heard 'banana' - close enough! üçå",
                    "Was that Klingon? üëΩ",
                    "Mumbling detected! üòÖ",
                    "Robot confused... beep boop! ü§ñ",
                    "Did you sneeze? Bless you! ü§ß",
                    "I'm not fluent in that language! üó£Ô∏è"
                ];

                const randomResponse = funnyResponses[Math.floor(Math.random() * funnyResponses.length)];
                document.getElementById('mishearEffect').textContent = randomResponse;

                // Create a fun visual effect
                gsap.fromTo('#mishearEffect',
                    { backgroundColor: '#374151', scale: 1 },
                    { backgroundColor: '#ec4899', scale: 1.05, duration: 0.3, yoyo: true, repeat: 1 }
                );

                // Sometimes randomly move anyway for fun
                if (Math.random() < 0.3) {
                    const randomMoves = ['left', 'right', 'up', 'down'];
                    const randomMove = randomMoves[Math.floor(Math.random() * randomMoves.length)];
                    this.setMovement(randomMove);
                    document.getElementById('mishearEffect').textContent += ` Moving ${randomMove} anyway! üòÑ`;
                }
            }

            setMovement(direction) {
                this.moveDirection = direction;
                this.isMoving = direction !== null;
            }

            updateVoiceStatus(status, listening) {
                document.getElementById('voiceStatus').textContent = status;
                const indicator = document.getElementById('voiceIndicator');
                const button = document.getElementById('startVoice');

                if (listening || this.shouldKeepListening) {
                    indicator.classList.add('listening');
                    button.textContent = 'üõë STOP LISTENING';
                    button.classList.remove('bg-cyan-600', 'hover:bg-cyan-700');
                    button.classList.add('bg-red-600', 'hover:bg-red-700');
                } else {
                    indicator.classList.remove('listening');
                    button.textContent = 'üé§ START VOICE CONTROL';
                    button.classList.remove('bg-red-600', 'hover:bg-red-700');
                    button.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                }
            }

            canMoveTo(x, y) {
                const gridX = Math.floor(x / this.cellSize);
                const gridY = Math.floor(y / this.cellSize);

                if (gridY < 0 || gridY >= this.maze.length || gridX < 0 || gridX >= this.maze[0].length) {
                    return false;
                }

                return this.maze[gridY][gridX] !== 0;
            }

            update() {
                if (this.isMoving && this.moveDirection && !this.gameWon) {
                    let newX = this.player.x;
                    let newY = this.player.y;

                    switch (this.moveDirection) {
                        case 'left':
                            newX -= this.moveSpeed;
                            break;
                        case 'right':
                            newX += this.moveSpeed;
                            break;
                        case 'up':
                            newY -= this.moveSpeed;
                            break;
                        case 'down':
                            newY += this.moveSpeed;
                            break;
                    }

                    // Check collision with walls
                    if (this.canMoveTo(newX, this.player.y)) {
                        this.player.x = newX;
                    }
                    if (this.canMoveTo(this.player.x, newY)) {
                        this.player.y = newY;
                    }

                    // Check if reached exit
                    const gridX = Math.floor(this.player.x / this.cellSize);
                    const gridY = Math.floor(this.player.y / this.cellSize);

                    if (this.maze[gridY] && this.maze[gridY][gridX] === 2) {
                        this.gameWon = true;
                        document.getElementById('gameStatus').textContent = 'üéâ YOU ESCAPED! üéâ';
                        document.getElementById('gameStatus').classList.add('neon-glow');

                        // Victory animation
                        gsap.fromTo('#gameStatus',
                            { scale: 1 },
                            { scale: 1.2, duration: 0.5, yoyo: true, repeat: 3 }
                        );
                    }
                }
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#0f0f23';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw maze
                for (let y = 0; y < this.maze.length; y++) {
                    for (let x = 0; x < this.maze[y].length; x++) {
                        const cellX = x * this.cellSize;
                        const cellY = y * this.cellSize;

                        if (this.maze[y][x] === 0) {
                            // Wall
                            this.ctx.fillStyle = '#1a1a3e';
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                            this.ctx.strokeStyle = '#333366';
                            this.ctx.strokeRect(cellX, cellY, this.cellSize, this.cellSize);
                        } else if (this.maze[y][x] === 1) {
                            // Path
                            this.ctx.fillStyle = '#2a2a4e';
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                        } else if (this.maze[y][x] === 2) {
                            // Exit
                            this.ctx.fillStyle = '#00ff00';
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = '16px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText('üö™', cellX + this.cellSize / 2, cellY + this.cellSize / 2 + 5);
                        }
                    }
                }

                // Draw player
                this.ctx.fillStyle = '#00ffff';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + this.player.size / 2, this.player.y + this.player.size / 2, this.player.size / 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Add glow effect to player
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 20;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + this.player.size / 2, this.player.y + this.player.size / 2, this.player.size / 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            resetGame() {
                this.player.x = 1;
                this.player.y = 1;
                this.gameWon = false;
                this.isMoving = false;
                this.moveDirection = null;
                document.getElementById('gameStatus').textContent = 'Find the exit! üö™';
                document.getElementById('gameStatus').classList.remove('neon-glow');
                document.getElementById('lastCommand').textContent = 'Waiting for voice...';
                document.getElementById('mishearEffect').textContent = 'Say something wrong for surprises! üòÑ';

                // Reset animation
                gsap.fromTo('#mazeCanvas',
                    { scale: 0.8, opacity: 0 },
                    { scale: 1, opacity: 1, duration: 0.5, ease: "back.out(1.7)" }
                );
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new VoiceMaze();
        });
    </script>
</body>

</html>